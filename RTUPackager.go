package modbus

import (
	"encoding/binary"
	"errors"
	"github.com/tarm/serial"
	"log"
)

type RTUPackager struct {
	PackagerSettings
	*serial.Port
}

func NewRTUPackager(c ConnectionSettings) (*RTUPackager, error) {
	p, err := NewSerialPort(c)
	if nil != err {
		return nil, err
	}
	return &RTUPackager{Port: p}, nil
}

// GeneratePacket generates the bytes of the packet for the given Query after
// validating that the Query is well formed. This must be called prior to
// calling Send.
func (pkgr *RTUPackager) GenerateADU() error {
	if pkgr.aduGenerated {
		return nil
	}

	if valid, err := pkgr.IsValid(); !valid {
		return err
	}

	if pkgr.SlaveID == 0 {
		return errors.New("SlaveID cannot be 0 for Modbus RTU")
	}

	packetLen := len(pkgr.Data) + 4
	if packetLen > MaxRTUSize {
		return errors.New("Query Data is too long")
	}

	packet := make([]byte, packetLen)
	packet[0] = pkgr.SlaveID
	packet[1] = pkgr.FunctionCode
	bytesUsed := 2

	bytesUsed += copy(packet[bytesUsed:], pkgr.Data)

	// add the crc to the end
	packetCrc := crc(packet[:bytesUsed])
	packet[bytesUsed] = byte(packetCrc & 0xff)
	packet[bytesUsed+1] = byte(packetCrc >> 8)
	bytesUsed += 2

	pkgr.adu = packet
	pkgr.aduGenerated = true
	return nil
}

// Send sends the packet generated by GeneratePacket and then reads, validates
// and returns the response bytes.
func (pkgr *RTUPackager) Send() ([]byte, error) {
	if err := pkgr.GenerateADU(); err != nil {
		return nil, err
	}

	if pkgr.Debug {
		log.Printf("Tx: %x\n", pkgr.adu)
	}

	// transmit the ADU to the slave device via the
	// serial port represented by the fd pointer
	_, err := pkgr.Write(pkgr.adu)
	if err != nil {
		return nil, err
	}

	// then attempt to read the reply
	response := make([]byte, MaxRTUSize)
	n, rerr := pkgr.Read(response)
	if rerr != nil {
		return nil, rerr
	}

	// check the validity of the response
	ok, err := pkgr.isValidResponse(response)
	if !ok {
		return nil, err
	}

	// confirm the checksum (lrc)
	computedCrc := crc(response[:n-2])
	if computedCrc != binary.LittleEndian.Uint16(response[n-2:]) {
		// return the response bytes anyway, and let the caller decide
		return response, exceptions[exceptionBadChecksum]
	}

	// return only the data payload
	//log.Println(FunctionNames[response[1]], response[:n-2])
	return response[2 : n-2], nil
}

// crc computes and returns a cyclic redundancy check of the given byte array
func crc(data []byte) uint16 {
	var crc16 uint16 = 0xffff
	l := len(data)
	for i := 0; i < l; i++ {
		crc16 ^= uint16(data[i])
		for j := 0; j < 8; j++ {
			if crc16&0x0001 > 0 {
				crc16 = (crc16 >> 1) ^ 0xA001
			} else {
				crc16 >>= 1
			}
		}
	}
	return crc16
}
