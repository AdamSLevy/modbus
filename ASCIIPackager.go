package modbus

import (
	"bytes"
	"encoding/hex"
	"errors"
	"github.com/tarm/serial"
	"log"
)

// ASCIIPackager generates packet frames from Queries, sends the packet, and
// reads and validates the response via the Transporter
type ASCIIPackager struct {
	PackagerSettings
	*serial.Port
}

func NewASCIIPackager(c ConnectionSettings) (*ASCIIPackager, error) {
	p, err := NewSerialPort(c)
	if nil != err {
		return nil, err
	}
	return &ASCIIPackager{Port: p}, nil
}

func NewSerialPort(c ConnectionSettings) (*serial.Port, error) {
	conf := &serial.Config{
		Name:        c.Host,
		Baud:        c.Baud,
		ReadTimeout: c.Timeout,
	}
	return serial.OpenPort(conf)
}

// GenerateADU generates the bytes of the packet for the given Query after
// validating that the Query is well formed. This must be called prior to
// calling Send.
func (pkgr *ASCIIPackager) GenerateADU() error {
	if pkgr.aduGenerated {
		return nil
	}

	if valid, err := pkgr.IsValid(); !valid {
		return err
	}
	if pkgr.SlaveID == 0 {
		return errors.New("SlaveID cannot be 0 for Modbus ASCII")
	}

	packetLen := 2
	packetLen += len(pkgr.Data) + 1
	if packetLen > MaxASCIISize {
		return errors.New("Query Data is too long")
	}

	rawPkt := make([]byte, packetLen)
	rawPkt[0] = pkgr.SlaveID
	rawPkt[1] = pkgr.FunctionCode
	bytesUsed := 2

	bytesUsed += copy(rawPkt[bytesUsed:], pkgr.Data)

	// add the lrc to the end
	pktLrc := lrc(rawPkt[:bytesUsed])
	rawPkt[bytesUsed] = byte(pktLrc)
	bytesUsed++

	// Convert raw bytes to ASCII packet
	asciiPkt := make([]byte, bytesUsed*2+3)
	hex.Encode(asciiPkt[1:], rawPkt)

	asciiBytesUsed := bytesUsed*2 + 1

	// Frame the packet
	asciiPkt[0] = ':'                 // 0x3A
	asciiPkt[asciiBytesUsed] = '\r'   // CR 0x0D
	asciiPkt[asciiBytesUsed+1] = '\n' // LF 0x0A
	asciiBytesUsed += 2

	pkgr.adu = bytes.ToUpper(asciiPkt)
	pkgr.aduGenerated = true
	return nil
}

// Send sends the packet generated by GeneratePacket and then reads, validates
// and returns the response bytes.
func (pkgr *ASCIIPackager) Send() ([]byte, error) {
	if err := pkgr.GenerateADU(); err != nil {
		return nil, err
	}
	if pkgr.Debug {
		log.Printf("Tx: %x\n", pkgr.adu)
		log.Printf("Tx: %s\n", pkgr.adu)
	}

	_, err := pkgr.Write(pkgr.adu)
	if err != nil {
		return nil, err
	}

	// then attempt to read the reply
	asciiResponse := make([]byte, MaxASCIISize)
	asciiN, rerr := pkgr.Read(asciiResponse)
	if rerr != nil {
		return nil, rerr
	}

	// check the framing of the response
	if asciiResponse[0] != ':' ||
		asciiResponse[asciiN-2] != '\r' ||
		asciiResponse[asciiN-1] != '\n' {
		return nil, exceptions[exceptionUnspecified]
	}

	// convert to raw bytes
	rawN := (asciiN - 3) / 2
	response := make([]byte, rawN)
	hex.Decode(response, asciiResponse[1:asciiN-2])

	// check the validity of the response
	ok, err := pkgr.isValidResponse(response)
	if !ok {
		return nil, err
	}

	// confirm the checksum (lrc)
	responseLrc := lrc(response[:rawN-1])
	if response[rawN-1] != responseLrc {
		// return the response bytes anyway, and let the caller decide
		return response, exceptions[exceptionBadChecksum]
	}

	// return only the data payload
	return response[2 : rawN-1], nil
}

// Modbus ASCII uses Longitudinal Redundancy Check. lrc computes and returns
// the 2's compliment (-) of the sum of the given byte array modulo 256
func lrc(data []byte) uint8 {
	var sum uint8
	var lrc8 uint8
	for _, b := range data {
		sum += b
	}
	lrc8 = uint8(-int8(sum))
	return lrc8
}
