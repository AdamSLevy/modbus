package modbus

import (
	//"encoding/binary"
	//"errors"
	"log"
	"net"
	"time"
)

// TCPPackager generates packet frames from Queries, sends the packet, and
// reads and validates the response via the Transporter
type TCPPackager struct {
	PackagerSettings
	SetAndValidateTransactionID bool
	net.Conn

	transactionID uint16
	timeout       time.Duration
}

// NewTCPPackager initializes a new TCPPackager with the given Transporter t.
func NewTCPPackager(c ConnectionSettings) (*TCPPackager, error) {
	// attempt to connect to the slave device (server)
	conn, err := net.DialTimeout("tcp", c.Host, c.Timeout)
	if err != nil {
		return nil, err
	}
	return &TCPPackager{
		Conn: conn,
		SetAndValidateTransactionID: true,
		timeout:                     c.Timeout,
	}, nil
}

// GeneratePacket is a method corresponding to a TCPFrame object which
// returns a byte array representing the associated TCP/IP application data
// unit (ADU)
func (pkgr *TCPPackager) GenerateADU() error {
	if pkgr.aduGenerated {
		return nil
	}
	if valid, err := pkgr.IsValid(); !valid {
		return err
	}

	packetLen := len(pkgr.Data) + 8
	packet := make([]byte, packetLen)
	packet[0] = byte(pkgr.transactionID >> 8)   // Transaction ID (High Byte)
	packet[1] = byte(pkgr.transactionID & 0xff) //                (Low Byte)
	packet[2] = 0x00                            // Protocol ID (2 bytes) -- always 00
	packet[3] = 0x00
	packet[4] = byte((len(pkgr.Data) + 2) >> 8)   // Length of remaining packet (High Byte)
	packet[5] = byte((len(pkgr.Data) + 2) & 0xff) // (Low Byte)

	packet[6] = pkgr.SlaveID
	packet[7] = pkgr.FunctionCode
	copy(packet[8:], pkgr.Data)

	pkgr.adu = packet
	pkgr.aduGenerated = true
	return nil
}

// Send sends the packet generated by GeneratePacket and then reads, validates
// and returns the response bytes.
func (pkgr *TCPPackager) Send() ([]byte, error) {
	if err := pkgr.GenerateADU(); err != nil {
		return nil, err
	}

	defer func() { pkgr.transactionID++ }()
	if pkgr.Debug {
		log.Printf("Tx: %x\n", pkgr.adu)
	}

	pkgr.SetDeadline(time.Now().Add(pkgr.timeout))

	// transmit the ADU
	_, err := pkgr.Write(pkgr.adu)
	if err != nil {
		log.Println("write err")
		return nil, err
	}

	// read the response
	response := make([]byte, MaxTCPSize)
	n, err := pkgr.Read(response)
	if err != nil {
		log.Println("Read error")
		return nil, err
	}

	// check the validity of the response
	//if binary.BigEndian.Uint16(response[2:3]) != pkgr.transactionID {
	//	return nil, errors.New("Mismatched transactionID")
	//}
	ok, err := pkgr.isValidResponse(response[6:])
	if !ok {
		return nil, err
	}

	// return only the number of bytes read
	return response[8:n], nil
}
